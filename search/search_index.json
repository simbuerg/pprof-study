{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BenchBuild Documentation BenchBuild is an open-source toolkit that helps with the management of case-studies used in software-driven empirical experiments. BenchBuild was specifically designed to make defined experiments reusable between different experiment setups. It mainly provides assistance with the following standard tasks found in empirical software experiments: Add a new case-study to an existing experiment setup. Add a new experiment to an existing body of case-studies. Design Philosophy BenchBuild is designed with the following main properties in mind. A case-study doesn't know its experiment If you add a new case-study, you should never have to rely on background information about the experiment you are about to run on it. A new case-study is only concerned with its own setup of dependencies and execution during its run-time. A case-study controls where and what can be intercepted by an experiment. An experiment doesn't know its case-studies Adding a new experiment never should have any knowledge about the case-studies it runs on. A new experiment takes care of intercepting the compilation process and/or the execution procedure of a given case-study. This only defines what is being done at the defined extension points at compile-time or run-time. Supported Python Versions BenchBuild supports Python 3.7 and 3.8. Main development is focused on Python 3.8, but an effort is made to support 3.7 as long as major distributions like Debian Linux only ship with 3.7 by default. Getting started See the Installation guide for help getting BenchBuild up and running quickly.","title":"BenchBuild Documentation"},{"location":"#benchbuild-documentation","text":"BenchBuild is an open-source toolkit that helps with the management of case-studies used in software-driven empirical experiments. BenchBuild was specifically designed to make defined experiments reusable between different experiment setups. It mainly provides assistance with the following standard tasks found in empirical software experiments: Add a new case-study to an existing experiment setup. Add a new experiment to an existing body of case-studies.","title":"BenchBuild Documentation"},{"location":"#design-philosophy","text":"BenchBuild is designed with the following main properties in mind.","title":"Design Philosophy"},{"location":"#a-case-study-doesnt-know-its-experiment","text":"If you add a new case-study, you should never have to rely on background information about the experiment you are about to run on it. A new case-study is only concerned with its own setup of dependencies and execution during its run-time. A case-study controls where and what can be intercepted by an experiment.","title":"A case-study doesn&#39;t know its experiment"},{"location":"#an-experiment-doesnt-know-its-case-studies","text":"Adding a new experiment never should have any knowledge about the case-studies it runs on. A new experiment takes care of intercepting the compilation process and/or the execution procedure of a given case-study. This only defines what is being done at the defined extension points at compile-time or run-time.","title":"An experiment doesn&#39;t know its case-studies"},{"location":"#supported-python-versions","text":"BenchBuild supports Python 3.7 and 3.8. Main development is focused on Python 3.8, but an effort is made to support 3.7 as long as major distributions like Debian Linux only ship with 3.7 by default.","title":"Supported Python Versions"},{"location":"#getting-started","text":"See the Installation guide for help getting BenchBuild up and running quickly.","title":"Getting started"},{"location":"CHANGELOG/","text":"","title":"Release Notes"},{"location":"advanced/","text":"TODO","title":"TODO"},{"location":"advanced/#todo","text":"","title":"TODO"},{"location":"basics/","text":"Installation The installation instructions are tested against Ubuntu 20.04 for Python 3.7 and Python 3.8. The particular commands required for installation depend on your setup. The dependencies below are not always mandatory, if they are not used. Requirements Dependency Minimum Version Notes Python 3.7 libpq 9.6 Required by psycopg2. libfuse 2.9.9 If uchroot is used. unionfs-fuse 1.0 If unionfs support is used. slurm-llnl 18.08 If slurm support is used. PostgreSQL The library dependency libpq is always need right now, because we make use of psycopg2 features internally. It is planned to get rid of this dependency in the future. FUSE BenchBuild can make use of unionfs and libfuse . This is often used in conjunction with a tool named uchroot which provides legacy support for user-space containers. This will be obsolete as soon as podman / buildah based OCI container support is considered stable. SLURM The cluster management software slurm is only required by 'name', i.e., we have to be able to import the binaries as python objects in benchbuild. As an alternative to installing slurm on your machine, you can always provide symlinks to /bin/true to the commands sbatch and srun . The minimum version should signal the minimum features set expected by BenchBuild when generating a slurm batch script. Benchbuild BenchBuild is released via pip and can be installed on your system as follows: pip install benchbuild [1] ( ) (b a s h) ( ) If you want to isolate BenchBuild from the rest of your system packages, you can install it in a dedicated virtual environment. virtualenv -ppython3 <venv_path> source <venv_path>/bin/activate pip3 install benchbuild [2] ( ) (b a s h) ( ) Bootstrapping BenchBuild provides a bootstrap procedure that checks a few key binaries on your system and tries to assist you in installation of any necessary binaries.","title":"Installation"},{"location":"basics/#installation","text":"The installation instructions are tested against Ubuntu 20.04 for Python 3.7 and Python 3.8. The particular commands required for installation depend on your setup. The dependencies below are not always mandatory, if they are not used.","title":"Installation"},{"location":"basics/#requirements","text":"Dependency Minimum Version Notes Python 3.7 libpq 9.6 Required by psycopg2. libfuse 2.9.9 If uchroot is used. unionfs-fuse 1.0 If unionfs support is used. slurm-llnl 18.08 If slurm support is used.","title":"Requirements"},{"location":"basics/#postgresql","text":"The library dependency libpq is always need right now, because we make use of psycopg2 features internally. It is planned to get rid of this dependency in the future.","title":"PostgreSQL"},{"location":"basics/#fuse","text":"BenchBuild can make use of unionfs and libfuse . This is often used in conjunction with a tool named uchroot which provides legacy support for user-space containers. This will be obsolete as soon as podman / buildah based OCI container support is considered stable.","title":"FUSE"},{"location":"basics/#slurm","text":"The cluster management software slurm is only required by 'name', i.e., we have to be able to import the binaries as python objects in benchbuild. As an alternative to installing slurm on your machine, you can always provide symlinks to /bin/true to the commands sbatch and srun . The minimum version should signal the minimum features set expected by BenchBuild when generating a slurm batch script.","title":"SLURM"},{"location":"basics/#benchbuild","text":"BenchBuild is released via pip and can be installed on your system as follows: pip install benchbuild [1] ( ) (b a s h) ( ) If you want to isolate BenchBuild from the rest of your system packages, you can install it in a dedicated virtual environment. virtualenv -ppython3 <venv_path> source <venv_path>/bin/activate pip3 install benchbuild [2] ( ) (b a s h) ( )","title":"Benchbuild"},{"location":"basics/#bootstrapping","text":"BenchBuild provides a bootstrap procedure that checks a few key binaries on your system and tries to assist you in installation of any necessary binaries.","title":"Bootstrapping"},{"location":"basics/configuration/","text":"module benchbuild. settings Settings module for benchbuild. All settings are stored in a simple dictionary. Each setting should be modifiable via environment variable.","title":"Configuration"},{"location":"concepts/environments/","text":"Environment module benchbuild.environments.domain. declarative BenchBuild supports containerized execution of all experiments. This gives you full control about the environment your projects and experiments may run in. The following example uses the latest alpine:latest Example ContainerImage () . from_ ( 'alpine:latest' ) . run ( 'apk' , 'update' ) . run ( 'apk' , 'add' , 'python3' ) Classes ContainerImage \u2014 Define a container image declaratively. Functions add_benchbuild_layers ( layers ) (ContainerImage) \u2014 Add benchbuild into the given container image. class benchbuild.environments.domain.declarative. ContainerImage ( iterable=() ) Bases list Define a container image declaratively. Start a new image using the .from_ method and provide a base image. Each method creates a new layer in the container image. Methods add ( sources , tgt ) (ContainerImage) \u2014 Add given files from the source to the container image. command ( *args ) (ContainerImage) \u2014 Set the default command the container runs. context ( func ) (ContainerImage) \u2014 Interact with the build context of the container. copy_ ( sources , tgt ) (ContainerImage) \u2014 Copy given files from the source to the container image. entrypoint ( *args ) (ContainerImage) \u2014 Set the entrypoint of the container. env ( **kwargs ) (ContainerImage) \u2014 Create an environment layer in this image. from_ ( base_image ) (ContainerImage) \u2014 Specify a new base layer for this image. run ( command , *args , **kwargs ) (ContainerImage) \u2014 Run a command in the container image. workingdir ( directory ) (ContainerImage) \u2014 Change the working directory in the container. method env ( **kwargs ) \u2192 ContainerImage Create an environment layer in this image. Dockerfile syntax: ENV Parameters kwargs (str) \u2014 a dictionary containing name/value pairings to be set as environment variables. method from_ ( base_image ) \u2192 ContainerImage Specify a new base layer for this image. Dockerfile syntax: FROM Parameters base_image (str) \u2014 The base image for our new container image. method context ( func ) \u2192 ContainerImage Interact with the build context of the container. Sometimes you have to interact with the build context of a container image. For example, you need to add artifacts to the build context before you can add the to the container image. BenchBuild uses this to add the sources to the container image automatically. Parameters func (tp.Callable[[], None]) \u2014 A callable that is executed in the build-context directory. method add ( sources , tgt ) \u2192 ContainerImage Add given files from the source to the container image. Dockerfile syntax: ADD [ ...] Parameters sources (tp.Iterable[str]) \u2014 Source path to add to the target tgt (str) \u2014 Absolute target path. method copy_ ( sources , tgt ) \u2192 ContainerImage Copy given files from the source to the container image. Dockerfile syntax: COPY [ ...] Parameters sources (tp.Iterable[str]) \u2014 Source path to add to the target tgt (str) \u2014 Absolute target path. method run ( command , *args , **kwargs ) \u2192 ContainerImage Run a command in the container image. Dockerfile syntax: RUN Parameters command (str) \u2014 The binary to execute in the container. *args (str) \u2014 Arguments that will be passed to the container. **kwargs (str) \u2014 Additional options that will be passed to the backend run command. method workingdir ( directory ) \u2192 ContainerImage Change the working directory in the container. Dockerfile syntax: WORKINGDIR All layers that follow this layer will be run with their working directory set to directory . Parameters directory (str) \u2014 The target directory to set our cwd to. method entrypoint ( *args ) \u2192 ContainerImage Set the entrypoint of the container. Dockerfile syntax: ENTRYPOINT This sets the default binary to run to the given command. Parameters *args (str) \u2014 A list of command components. method command ( *args ) \u2192 ContainerImage Set the default command the container runs. Dockerfile syntax: CMD Parameters *args (str) \u2014 A list of command components. function benchbuild.environments.domain.declarative. add_benchbuild_layers ( layers ) Add benchbuild into the given container image. This assumes all necessary depenencies are available in the image already. The installation is done, either using pip from a remote mirror, or using the source checkout of benchbuild. A source installation requires your buildah/podman installation to be able to complete a bind-mount as the user that runs benchbuild. Parameters layers (ContainerImage) \u2014 a container image we will add our install layers to. Returns (ContainerImage) the modified container image.","title":"Environment"},{"location":"concepts/environments/#environment","text":"module benchbuild.environments.domain. declarative BenchBuild supports containerized execution of all experiments. This gives you full control about the environment your projects and experiments may run in. The following example uses the latest alpine:latest Example ContainerImage () . from_ ( 'alpine:latest' ) . run ( 'apk' , 'update' ) . run ( 'apk' , 'add' , 'python3' ) Classes ContainerImage \u2014 Define a container image declaratively. Functions add_benchbuild_layers ( layers ) (ContainerImage) \u2014 Add benchbuild into the given container image. class benchbuild.environments.domain.declarative. ContainerImage ( iterable=() ) Bases list Define a container image declaratively. Start a new image using the .from_ method and provide a base image. Each method creates a new layer in the container image. Methods add ( sources , tgt ) (ContainerImage) \u2014 Add given files from the source to the container image. command ( *args ) (ContainerImage) \u2014 Set the default command the container runs. context ( func ) (ContainerImage) \u2014 Interact with the build context of the container. copy_ ( sources , tgt ) (ContainerImage) \u2014 Copy given files from the source to the container image. entrypoint ( *args ) (ContainerImage) \u2014 Set the entrypoint of the container. env ( **kwargs ) (ContainerImage) \u2014 Create an environment layer in this image. from_ ( base_image ) (ContainerImage) \u2014 Specify a new base layer for this image. run ( command , *args , **kwargs ) (ContainerImage) \u2014 Run a command in the container image. workingdir ( directory ) (ContainerImage) \u2014 Change the working directory in the container. method env ( **kwargs ) \u2192 ContainerImage Create an environment layer in this image. Dockerfile syntax: ENV Parameters kwargs (str) \u2014 a dictionary containing name/value pairings to be set as environment variables. method from_ ( base_image ) \u2192 ContainerImage Specify a new base layer for this image. Dockerfile syntax: FROM Parameters base_image (str) \u2014 The base image for our new container image. method context ( func ) \u2192 ContainerImage Interact with the build context of the container. Sometimes you have to interact with the build context of a container image. For example, you need to add artifacts to the build context before you can add the to the container image. BenchBuild uses this to add the sources to the container image automatically. Parameters func (tp.Callable[[], None]) \u2014 A callable that is executed in the build-context directory. method add ( sources , tgt ) \u2192 ContainerImage Add given files from the source to the container image. Dockerfile syntax: ADD [ ...] Parameters sources (tp.Iterable[str]) \u2014 Source path to add to the target tgt (str) \u2014 Absolute target path. method copy_ ( sources , tgt ) \u2192 ContainerImage Copy given files from the source to the container image. Dockerfile syntax: COPY [ ...] Parameters sources (tp.Iterable[str]) \u2014 Source path to add to the target tgt (str) \u2014 Absolute target path. method run ( command , *args , **kwargs ) \u2192 ContainerImage Run a command in the container image. Dockerfile syntax: RUN Parameters command (str) \u2014 The binary to execute in the container. *args (str) \u2014 Arguments that will be passed to the container. **kwargs (str) \u2014 Additional options that will be passed to the backend run command. method workingdir ( directory ) \u2192 ContainerImage Change the working directory in the container. Dockerfile syntax: WORKINGDIR All layers that follow this layer will be run with their working directory set to directory . Parameters directory (str) \u2014 The target directory to set our cwd to. method entrypoint ( *args ) \u2192 ContainerImage Set the entrypoint of the container. Dockerfile syntax: ENTRYPOINT This sets the default binary to run to the given command. Parameters *args (str) \u2014 A list of command components. method command ( *args ) \u2192 ContainerImage Set the default command the container runs. Dockerfile syntax: CMD Parameters *args (str) \u2014 A list of command components. function benchbuild.environments.domain.declarative. add_benchbuild_layers ( layers ) Add benchbuild into the given container image. This assumes all necessary depenencies are available in the image already. The installation is done, either using pip from a remote mirror, or using the source checkout of benchbuild. A source installation requires your buildah/podman installation to be able to complete a bind-mount as the user that runs benchbuild. Parameters layers (ContainerImage) \u2014 a container image we will add our install layers to. Returns (ContainerImage) the modified container image.","title":"Environment"},{"location":"concepts/experiments/","text":"Experiment TODO.","title":"Experiment"},{"location":"concepts/experiments/#experiment","text":"TODO.","title":"Experiment"},{"location":"concepts/projects/","text":"Project TODO.","title":"Project"},{"location":"concepts/projects/#project","text":"TODO.","title":"Project"},{"location":"concepts/source/","text":"Source TODO. General module benchbuild.source. base Provide a base interface for downloadable sources. Classes Variant \u2014 Provide a 'string'-like wrapper around source version information. Fetchable \u2014 Base class for protocol classes. Expandable \u2014 Base class for protocol classes. Versioned \u2014 Base class for protocol classes. FetchableSource ( *args , **kwds ) \u2014 Base class for fetchable sources. NoSource \u2014 Base class for fetchable sources. Functions context ( *variants ) (dict(str: Variant)) \u2014 Convert an arbitrary number of variants into a VariantContext. default ( *sources ) (dict(str: Variant)) \u2014 Return the collective 'default' version for the given sources. primary ( *sources ) (SourceT) \u2014 Return the implicit 'main' source of a project. product ( *sources ) (iterable of (any, ...)) \u2014 Return the cross product of the given sources. sources_as_dict ( *sources ) (dict(str: Fetchable)) \u2014 Convert fetchables to a dictionary. target_prefix ( ) (str) \u2014 Return the prefix directory for all downloads. to_str ( *variants ) (str) \u2014 Convert an arbitrary number of variants into their string representation. Versioning module benchbuild.source. versions Classes BaseVersionGroup ( *args , **kwds ) \u2014 Base class for protocol classes. BaseVersionFilter ( *args , **kwds ) \u2014 Base class for fetchable sources. SingleVersionFilter \u2014 A simple single versions only filter. HTTP class benchbuild.source.http. HTTP ( *args , **kwds ) Bases benchbuild.source.base.FetchableSource benchbuild.source.base.Fetchable benchbuild.source.base.Expandable benchbuild.source.base.Versioned typing.Protocol typing.Generic Fetch the downloadable source via http. Classes _ProtocolMeta \u2014 Metaclass for defining Abstract Base Classes (ABCs). Methods __init_subclass__ ( *args , **kwargs ) \u2014 This method is called when a class is subclassed. version ( target_dir , version ) (str) \u2014 Fetch the requested version and place it in the target_dir versions ( ) (List[str]) \u2014 List all available versions of this source. class typing. _ProtocolMeta ( name , bases , namespace , **kwargs ) Bases abc.ABCMeta Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). Methods __instancecheck__ ( cls , instance ) \u2014 Override for isinstance(instance, cls). __subclasscheck__ ( cls , subclass ) \u2014 Override for issubclass(subclass, cls). register ( cls , subclass ) \u2014 Register a virtual subclass of an ABC. staticmethod register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. staticmethod __subclasscheck__ ( cls , subclass ) Override for issubclass(subclass, cls). staticmethod __instancecheck__ ( cls , instance ) Override for isinstance(instance, cls). classmethod __init_subclass__ ( *args , **kwargs ) This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method version ( target_dir , version ) Fetch the requested version and place it in the target_dir Parameters target_dir (str) \u2014 The filesystem path where the version should be placed in. version (str) \u2014 The version that should be fetched from the local cache. Returns (str) [description] method versions ( ) List all available versions of this source. Returns (List[str]) The list of all available versions. Git class benchbuild.source.git. Git ( *args , **kwds ) Bases benchbuild.source.base.FetchableSource benchbuild.source.base.Fetchable benchbuild.source.base.Expandable benchbuild.source.base.Versioned typing.Protocol typing.Generic Fetch the downloadable source via git. Attributes default (Variant) \u2014 Return current HEAD as default version for this Git project. Classes _ProtocolMeta \u2014 Metaclass for defining Abstract Base Classes (ABCs). Methods __init_subclass__ ( *args , **kwargs ) \u2014 This method is called when a class is subclassed. fetch ( ) (str) \u2014 Clone the repository, if needed. version ( target_dir , version ) (str) \u2014 Create a new git worktree pointing to the requested version. versions ( ) (List[str]) \u2014 List all available versions of this source. class typing. _ProtocolMeta ( name , bases , namespace , **kwargs ) Bases abc.ABCMeta Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). Methods __instancecheck__ ( cls , instance ) \u2014 Override for isinstance(instance, cls). __subclasscheck__ ( cls , subclass ) \u2014 Override for issubclass(subclass, cls). register ( cls , subclass ) \u2014 Register a virtual subclass of an ABC. staticmethod register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. staticmethod __subclasscheck__ ( cls , subclass ) Override for issubclass(subclass, cls). staticmethod __instancecheck__ ( cls , instance ) Override for isinstance(instance, cls). classmethod __init_subclass__ ( *args , **kwargs ) This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method fetch ( ) Clone the repository, if needed. This will create a git clone inside the global cache directory. Parameters version (Optional[str], optional) \u2014 [description]. Defaults to None. Returns (str) [description] method version ( target_dir , version='HEAD' ) Create a new git worktree pointing to the requested version. Parameters target_dir (str) \u2014 The filesystem path where the new worktree should live. version (str) \u2014 The desired version the new worktree needs to point to. Defaults to 'HEAD'. Returns (str) [description] method versions ( ) List all available versions of this source. Returns (List[str]) The list of all available versions. class benchbuild.source.git. GitSubmodule ( *args , **kwds ) Bases benchbuild.source.git.Git benchbuild.source.base.FetchableSource benchbuild.source.base.Fetchable benchbuild.source.base.Expandable benchbuild.source.base.Versioned typing.Protocol typing.Generic Fetch the downloadable source via git. Attributes default (Variant) \u2014 Return current HEAD as default version for this Git project. is_expandable (bool) \u2014 Submodules will not participate in version expansion. Classes _ProtocolMeta \u2014 Metaclass for defining Abstract Base Classes (ABCs). Methods __init_subclass__ ( *args , **kwargs ) \u2014 This method is called when a class is subclassed. fetch ( ) (str) \u2014 Clone the repository, if needed. version ( target_dir , version ) (str) \u2014 Create a new git worktree pointing to the requested version. versions ( ) (List[str]) \u2014 List all available versions of this source. class typing. _ProtocolMeta ( name , bases , namespace , **kwargs ) Bases abc.ABCMeta Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). Methods __instancecheck__ ( cls , instance ) \u2014 Override for isinstance(instance, cls). __subclasscheck__ ( cls , subclass ) \u2014 Override for issubclass(subclass, cls). register ( cls , subclass ) \u2014 Register a virtual subclass of an ABC. staticmethod register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. staticmethod __subclasscheck__ ( cls , subclass ) Override for issubclass(subclass, cls). staticmethod __instancecheck__ ( cls , instance ) Override for isinstance(instance, cls). classmethod __init_subclass__ ( *args , **kwargs ) This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method fetch ( ) Clone the repository, if needed. This will create a git clone inside the global cache directory. Parameters version (Optional[str], optional) \u2014 [description]. Defaults to None. Returns (str) [description] method version ( target_dir , version='HEAD' ) Create a new git worktree pointing to the requested version. Parameters target_dir (str) \u2014 The filesystem path where the new worktree should live. version (str) \u2014 The desired version the new worktree needs to point to. Defaults to 'HEAD'. Returns (str) [description] method versions ( ) List all available versions of this source. Returns (List[str]) The list of all available versions. Rsync TODO.","title":"Source"},{"location":"concepts/source/#source","text":"TODO.","title":"Source"},{"location":"concepts/source/#general","text":"module benchbuild.source. base Provide a base interface for downloadable sources. Classes Variant \u2014 Provide a 'string'-like wrapper around source version information. Fetchable \u2014 Base class for protocol classes. Expandable \u2014 Base class for protocol classes. Versioned \u2014 Base class for protocol classes. FetchableSource ( *args , **kwds ) \u2014 Base class for fetchable sources. NoSource \u2014 Base class for fetchable sources. Functions context ( *variants ) (dict(str: Variant)) \u2014 Convert an arbitrary number of variants into a VariantContext. default ( *sources ) (dict(str: Variant)) \u2014 Return the collective 'default' version for the given sources. primary ( *sources ) (SourceT) \u2014 Return the implicit 'main' source of a project. product ( *sources ) (iterable of (any, ...)) \u2014 Return the cross product of the given sources. sources_as_dict ( *sources ) (dict(str: Fetchable)) \u2014 Convert fetchables to a dictionary. target_prefix ( ) (str) \u2014 Return the prefix directory for all downloads. to_str ( *variants ) (str) \u2014 Convert an arbitrary number of variants into their string representation.","title":"General"},{"location":"concepts/source/#versioning","text":"module benchbuild.source. versions Classes BaseVersionGroup ( *args , **kwds ) \u2014 Base class for protocol classes. BaseVersionFilter ( *args , **kwds ) \u2014 Base class for fetchable sources. SingleVersionFilter \u2014 A simple single versions only filter.","title":"Versioning"},{"location":"concepts/source/#http","text":"class benchbuild.source.http. HTTP ( *args , **kwds ) Bases benchbuild.source.base.FetchableSource benchbuild.source.base.Fetchable benchbuild.source.base.Expandable benchbuild.source.base.Versioned typing.Protocol typing.Generic Fetch the downloadable source via http. Classes _ProtocolMeta \u2014 Metaclass for defining Abstract Base Classes (ABCs). Methods __init_subclass__ ( *args , **kwargs ) \u2014 This method is called when a class is subclassed. version ( target_dir , version ) (str) \u2014 Fetch the requested version and place it in the target_dir versions ( ) (List[str]) \u2014 List all available versions of this source. class typing. _ProtocolMeta ( name , bases , namespace , **kwargs ) Bases abc.ABCMeta Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). Methods __instancecheck__ ( cls , instance ) \u2014 Override for isinstance(instance, cls). __subclasscheck__ ( cls , subclass ) \u2014 Override for issubclass(subclass, cls). register ( cls , subclass ) \u2014 Register a virtual subclass of an ABC. staticmethod register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. staticmethod __subclasscheck__ ( cls , subclass ) Override for issubclass(subclass, cls). staticmethod __instancecheck__ ( cls , instance ) Override for isinstance(instance, cls). classmethod __init_subclass__ ( *args , **kwargs ) This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method version ( target_dir , version ) Fetch the requested version and place it in the target_dir Parameters target_dir (str) \u2014 The filesystem path where the version should be placed in. version (str) \u2014 The version that should be fetched from the local cache. Returns (str) [description] method versions ( ) List all available versions of this source. Returns (List[str]) The list of all available versions.","title":"HTTP"},{"location":"concepts/source/#git","text":"class benchbuild.source.git. Git ( *args , **kwds ) Bases benchbuild.source.base.FetchableSource benchbuild.source.base.Fetchable benchbuild.source.base.Expandable benchbuild.source.base.Versioned typing.Protocol typing.Generic Fetch the downloadable source via git. Attributes default (Variant) \u2014 Return current HEAD as default version for this Git project. Classes _ProtocolMeta \u2014 Metaclass for defining Abstract Base Classes (ABCs). Methods __init_subclass__ ( *args , **kwargs ) \u2014 This method is called when a class is subclassed. fetch ( ) (str) \u2014 Clone the repository, if needed. version ( target_dir , version ) (str) \u2014 Create a new git worktree pointing to the requested version. versions ( ) (List[str]) \u2014 List all available versions of this source. class typing. _ProtocolMeta ( name , bases , namespace , **kwargs ) Bases abc.ABCMeta Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). Methods __instancecheck__ ( cls , instance ) \u2014 Override for isinstance(instance, cls). __subclasscheck__ ( cls , subclass ) \u2014 Override for issubclass(subclass, cls). register ( cls , subclass ) \u2014 Register a virtual subclass of an ABC. staticmethod register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. staticmethod __subclasscheck__ ( cls , subclass ) Override for issubclass(subclass, cls). staticmethod __instancecheck__ ( cls , instance ) Override for isinstance(instance, cls). classmethod __init_subclass__ ( *args , **kwargs ) This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method fetch ( ) Clone the repository, if needed. This will create a git clone inside the global cache directory. Parameters version (Optional[str], optional) \u2014 [description]. Defaults to None. Returns (str) [description] method version ( target_dir , version='HEAD' ) Create a new git worktree pointing to the requested version. Parameters target_dir (str) \u2014 The filesystem path where the new worktree should live. version (str) \u2014 The desired version the new worktree needs to point to. Defaults to 'HEAD'. Returns (str) [description] method versions ( ) List all available versions of this source. Returns (List[str]) The list of all available versions. class benchbuild.source.git. GitSubmodule ( *args , **kwds ) Bases benchbuild.source.git.Git benchbuild.source.base.FetchableSource benchbuild.source.base.Fetchable benchbuild.source.base.Expandable benchbuild.source.base.Versioned typing.Protocol typing.Generic Fetch the downloadable source via git. Attributes default (Variant) \u2014 Return current HEAD as default version for this Git project. is_expandable (bool) \u2014 Submodules will not participate in version expansion. Classes _ProtocolMeta \u2014 Metaclass for defining Abstract Base Classes (ABCs). Methods __init_subclass__ ( *args , **kwargs ) \u2014 This method is called when a class is subclassed. fetch ( ) (str) \u2014 Clone the repository, if needed. version ( target_dir , version ) (str) \u2014 Create a new git worktree pointing to the requested version. versions ( ) (List[str]) \u2014 List all available versions of this source. class typing. _ProtocolMeta ( name , bases , namespace , **kwargs ) Bases abc.ABCMeta Metaclass for defining Abstract Base Classes (ABCs). Use this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()). Methods __instancecheck__ ( cls , instance ) \u2014 Override for isinstance(instance, cls). __subclasscheck__ ( cls , subclass ) \u2014 Override for issubclass(subclass, cls). register ( cls , subclass ) \u2014 Register a virtual subclass of an ABC. staticmethod register ( cls , subclass ) Register a virtual subclass of an ABC. Returns the subclass, to allow usage as a class decorator. staticmethod __subclasscheck__ ( cls , subclass ) Override for issubclass(subclass, cls). staticmethod __instancecheck__ ( cls , instance ) Override for isinstance(instance, cls). classmethod __init_subclass__ ( *args , **kwargs ) This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method fetch ( ) Clone the repository, if needed. This will create a git clone inside the global cache directory. Parameters version (Optional[str], optional) \u2014 [description]. Defaults to None. Returns (str) [description] method version ( target_dir , version='HEAD' ) Create a new git worktree pointing to the requested version. Parameters target_dir (str) \u2014 The filesystem path where the new worktree should live. version (str) \u2014 The desired version the new worktree needs to point to. Defaults to 'HEAD'. Returns (str) [description] method versions ( ) List all available versions of this source. Returns (List[str]) The list of all available versions.","title":"Git"},{"location":"concepts/source/#rsync","text":"TODO.","title":"Rsync"}]}